

(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) 
             (= kinds-of-coins 0)) 
         0)
        (else 
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(cc 11 5)
(+ (cc 11 4) (cc -39 5))
(+ (+ (cc 11 3) (cc -14 4)) 0)
(+ (+ (+ (cc 11 2) (cc 1 3)) 0) 0)
(+ (+ (+ (+ (cc 11 1) (cc 6 2)) (+ (cc 1 2) (cc -9 3))) 0) 0)
(+ (+ (+ (+ (+ (cc 11 0) (cc 10 1)) (+ (cc 6 1) (cc 1 2))) (+ (+ (cc 1 1) (cc -4 2)) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ (cc 10 0) (cc 9 1))) (+ (+ (cc 6 0) (cc 5 1)) (+ (cc 1 1) (cc -4 2)))) (+ (+ (+ (cc 1 0) (cc 0 1)) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ (cc 9 0) (cc 8 1)))) (+ (+ 0 (+ (cc 5 0) (cc 4 1))) (+ (+ (cc 1 0) (cc 0 1)) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ (cc 8 0) (cc 7 1))))) (+ (+ 0 (+ 0 (+ (cc 4 0) (cc 3 1)))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 7 0) (cc 6 1)))))) (+ (+ 0 (+ 0 (+ 0 (+ (cc 3 0) (cc 2 1))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 6 0) (cc 5 1))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 2 0) (cc 1 1)))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 5 0) (cc 4 1)))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 1 0) (cc 0 1))))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 4 0) (cc 3 1))))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 3 0) (cc 2 1)))))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 2 0) (cc 1 1))))))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ (cc 1 0) (cc 0 1)))))))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1))))))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 0))) (+ (+ (+ 0 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1))))) (+ 1 0))) (+ (+ 1 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1))))))))) (+ (+ 0 (+ 0 (+ 0 (+ 0 1)))) 1)) (+ 1 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))))) (+ (+ 0 (+ 0 (+ 0 1))) 1)) 1) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1))))))) (+ (+ 0 (+ 0 1)) 1)) 1) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1)))))) (+ (+ 0 1) 1)) 1) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 (+ 0 1))))) (+ 1 1)) 1) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (+ 0 1)))) 2) 1) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 1))) 2) 1) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 1)) 2) 1) 0) 0)
(+ (+ (+ (+ (+ 0 1) 2) 1) 0) 0)
(+ (+ (+ (+ 1 2) 1) 0) 0)
(+ (+ (+ 3 1) 0) 0)
(+ (+ 4 0) 0)
(+ 4 0)
(4)


;; 01:
;; First we have to draw the tree of the process generated by the count-change procedure.
;; I will use pydot(python interface for graphviz) to make the graph.
;; https://github.com/Dreemsuncho/Structure-and-Interpretation-of-Computer-Programs--SICP--Second-Edition-Exercises/blob/master/assets/Count%20change%20graph.png

;; Gray and blue nodes are the leaf nodes, but only blue nodes contributes to the final answer.
;; Here is the Python implementation of count_change procedure along with pydot graph additions if you want to play with generated tree and different inputs.
;; https://github.com/Dreemsuncho/Structure-and-Interpretation-of-Computer-Programs--SICP--Second-Edition-Exercises/blob/master/utils/count_change_graph.py

;; 02:
;; Now for orders of complexity.

;; A) Space:
;; As book teach us, we have to consider the longest depth of the tree and clearly we see that the longet path is when the coins remains 1, because when we call the count_change procedure with 1 kinds of coins we see that our levels are equal to the amount and every level has two calls to itself(but this doesn't matter because only the call that have one coin recurr deeper), and thus we can conclude that the space required for this procedure is linear or O(n).


;; Time/steps:
;; If we see the output for 2 cents with one coin
;; https://github.com/Dreemsuncho/Structure-and-Interpretation-of-Computer-Programs--SICP--Second-Edition-Exercises/blob/master/assets/2%201.png
;; we can see very clear that when the coin remains 1 the number of calls are 2*2+1, see also 3 cents with 1 coin is the same pattern 2*3+1
;; https://github.com/Dreemsuncho/Structure-and-Interpretation-of-Computer-Programs--SICP--Second-Edition-Exercises/blob/master/assets/3%201.png
;; From this we can say regardless the amount we use with 1 coin, the orders of growth for time is 2n+1.

;; Lets use this formula F(amount=n, kinds_of_coins=1) = 2n+1 steps.

;; To clarify real orders of growth, see this call of count_change for 6 amount and 2 coins
;; https://github.com/Dreemsuncho/Structure-and-Interpretation-of-Computer-Programs--SICP--Second-Edition-Exercises/blob/master/assets/6%202.png
;; in the left branch we see the old pattern apply for 6 amount and 1 coin, but in addition we have right branch that call itself with 5 cents less and same amount of coins, from this we can see the right branch is the same pattern but with 5 cents less for the amount, this means every right branch with 2 kinds of coins call itself with 5 cents less for the amount till reach 0 or less and make another completely new left branch with 1 coins remaining and the same amount.
;; From this we can conclude that the orders of growth for steps is.
;; F(amount=n, kinds_of_coins=2) = (n/5) * 2n+1.
;; And now we see orders of growth is (n/5)*2 or O(n²).
;; Lets make the last steps and finish the question from the exercise, consider the procedure called with 11 amount and 3 coins
;; https://github.com/Dreemsuncho/Structure-and-Interpretation-of-Computer-Programs--SICP--Second-Edition-Exercises/blob/master/assets/11%203.png
;; again right branch is the same coins, but amount is reduced with 10 cents and every right branch make entire new left branch with one coin less and the pattern apply again for one more coin less, if you can recognize the pattern you can see that 
;; F(amount=n, kinds_of_coins=3) = (n/10) * (n/5) * 2n+1 or O(n³)
;; F(amount=n, kinds_of_coins=4) = (n/25) * (n/10) * (n/5) * 2n+1 or O(n⁴)
;; F(amount=n, kinds_of_coins=5) = (n/50) * (n/25) * (n/10) * (n/5) * 2n+1 or O(n⁵)
;; And from this we can say the orders of growth for any amount and 5 coins is O(n⁵) and this is the answer for the last question for the count_change(amount=11, coins=5).


